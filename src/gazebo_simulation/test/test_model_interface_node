#!/usr/bin/env python3
import sys
import unittest
import rospy
import math
import rostest

import gazebo_msgs.srv as gazebo_srvs

from geometry.vector import Vector
from geometry.pose import Pose
from geometry.point import Point
import geometry_msgs.msg as geometry_msgs
from ros_base.node_base import NodeBase

from gazebo_simulation.srv import (
    GetModelPoseRequest,
    GetModelPose,
    GetModelTwistRequest,
    GetModelTwist,
    SetModelPose,
    SetModelPoseRequest,
    SetModelTwist,
    SetModelTwistRequest,
)

PKG = "gazebo_simulation"


class ModelInterfaceNodeTest(unittest.TestCase, NodeBase):
    """Unittest that is executed through a ROS test and checks the functionality
    of the model_interface_node and the model_interface_visualization_node.
    """

    def setUp(self):
        NodeBase.__init__(self, name="test_model_interface_node")

        set_srv_topic = "/gazebo/set_model_state"

        rospy.wait_for_service(set_srv_topic)

        self.gazebo_set_state = rospy.ServiceProxy(set_srv_topic, gazebo_srvs.SetModelState)

        # Use model interface service to get vehicles pose
        self.model_interface_get_pose = rospy.ServiceProxy(
            self.param.topics.model_interface.get.model_pose, GetModelPose
        )
        self.model_interface_get_twist = rospy.ServiceProxy(
            self.param.topics.model_interface.get.model_twist, GetModelTwist
        )

        # Model interface setters
        self.model_interface_set_state = rospy.ServiceProxy(
            self.param.topics.model_interface.set.model_state, gazebo_srvs.SetModelState
        )
        self.model_interface_set_pose = rospy.ServiceProxy(
            self.param.topics.model_interface.set.model_pose, SetModelPose
        )
        self.model_interface_set_twist = rospy.ServiceProxy(
            self.param.topics.model_interface.set.model_twist, SetModelTwist
        )

        # Ensure that vehicle is not moving in the beginning
        pose = Pose(Point(0, 0, 0), 0)
        new_state = gazebo_srvs.SetModelState()
        new_state.model_name = self.param.car_name
        new_state.pose = pose.to_geometry_msg()
        new_state.twist = geometry_msgs.Twist(
            linear=geometry_msgs.Vector3(0, 0, 0), angular=geometry_msgs.Vector3(0, 0, 0)
        )
        new_state.reference_frame = ""
        self.gazebo_set_state(new_state)

        # Wait for some time...
        rospy.sleep(self.param.sleep_time)

    def tearDown(self):
        self.gazebo_set_state.close()
        self.model_interface_get_pose.close()
        self.model_interface_get_twist.close()
        self.model_interface_set_state.close()
        self.model_interface_set_pose.close()
        self.model_interface_set_twist.close()

    def test_get_model_information(self):
        """Basically just tell gazebo to put the car somewhere and check if model_interface_node tells the correct
        pose and twist.
        """
        pose = Pose(Point(3, 4, 0), math.pi)

        new_state = gazebo_srvs.SetModelState()
        new_state.model_name = self.param.car_name
        new_state.pose = pose.to_geometry_msg()
        new_state.twist = geometry_msgs.Twist(
            linear=geometry_msgs.Vector3(0, 0, 0), angular=geometry_msgs.Vector3(0, 0, 0)
        )
        new_state.reference_frame = ""
        self.gazebo_set_state(new_state)

        # Wait for some time...
        rospy.sleep(self.param.sleep_time)

        received_pose = Pose(self.model_interface_get_pose(GetModelPoseRequest(self.param.car_name)).pose)
        rospy.loginfo(f"Received pose: {received_pose}")
        self.assertAlmostEqual(Vector(pose), Vector(received_pose), delta=self.param.tolerance)
        self.assertAlmostEqual(pose.get_angle(), received_pose.get_angle(), delta=self.param.tolerance)

        # Now check twist
        new_state = gazebo_srvs.SetModelState()
        new_state.model_name = self.param.car_name
        new_state.pose = pose.to_geometry_msg()
        twist = geometry_msgs.Twist(linear=geometry_msgs.Vector3(10, 0, 0), angular=geometry_msgs.Vector3(0, 0, 0))
        new_state.reference_frame = ""

        new_state.twist = twist
        self.gazebo_set_state(new_state)

        # Wait for some time...
        rospy.sleep(self.param.sleep_time)

        received_twist = self.model_interface_get_twist(GetModelTwistRequest(self.param.car_name)).twist
        rospy.loginfo(f"Received twist: {received_twist}")
        self.assertAlmostEqual(Vector(twist.linear), Vector(received_twist.linear), delta=self.param.tolerance)
        self.assertAlmostEqual(Vector(twist.angular), Vector(received_twist.angular), delta=self.param.tolerance)

    def test_set_model_state(self):
        """Basically put the car somewhere and check if model_interface_node tells the correct state.

        The difference to the test_get_model_information is that the model interface set state service is tested!
        The get functions are assumed to work because it's been tested in the previous test.
        """
        pose = Pose(Point(3, 4, 0), math.pi)

        new_state = gazebo_srvs.SetModelState()
        new_state.model_name = self.param.car_name
        new_state.pose = pose.to_geometry_msg()
        new_state.twist = geometry_msgs.Twist(
            linear=geometry_msgs.Vector3(0, 0, 0), angular=geometry_msgs.Vector3(0, 0, 0)
        )
        new_state.reference_frame = ""
        self.model_interface_set_state(new_state)

        # Wait for some time...
        rospy.sleep(self.param.sleep_time)

        received_pose = Pose(self.model_interface_get_pose(GetModelPoseRequest(self.param.car_name)).pose)
        rospy.loginfo(f"Received pose: {received_pose}")
        self.assertAlmostEqual(Vector(pose), Vector(received_pose), delta=self.param.tolerance)
        self.assertAlmostEqual(pose.get_angle(), received_pose.get_angle(), delta=self.param.tolerance)

        # Now check twist
        new_state = gazebo_srvs.SetModelState()
        new_state.model_name = self.param.car_name
        new_state.pose = pose.to_geometry_msg()
        twist = geometry_msgs.Twist(linear=geometry_msgs.Vector3(10, 0, 0), angular=geometry_msgs.Vector3(0, 0, 0))
        new_state.reference_frame = ""

        new_state.twist = twist
        self.model_interface_set_state(new_state)

        # Wait for some time...
        rospy.sleep(self.param.sleep_time)

        received_twist = self.model_interface_get_twist(GetModelTwistRequest(self.param.car_name)).twist
        rospy.loginfo(f"Received twist: {received_twist}")
        self.assertAlmostEqual(Vector(twist.linear), Vector(received_twist.linear), delta=self.param.tolerance)
        self.assertAlmostEqual(Vector(twist.angular), Vector(received_twist.angular), delta=self.param.tolerance)

    def test_set_model_pose(self):
        """Basically put the car somewhere and check if model_interface_node tells the correct pose.
        """
        pose = Pose(Point(3, 4, 0), math.pi)

        self.model_interface_set_pose(SetModelPoseRequest(self.param.car_name, pose.to_geometry_msg()))

        # Wait for some time...
        rospy.sleep(self.param.sleep_time)

        received_pose = Pose(self.model_interface_get_pose(GetModelPoseRequest(self.param.car_name)).pose)
        rospy.loginfo(f"Received pose: {received_pose}")
        self.assertAlmostEqual(Vector(pose), Vector(received_pose), delta=self.param.tolerance)
        self.assertAlmostEqual(pose.get_angle(), received_pose.get_angle(), delta=self.param.tolerance)

    def test_set_model_twist(self):
        """Basically put the car somewhere and check if model_interface_node tells the correct pose.
        """
        twist = geometry_msgs.Twist(linear=geometry_msgs.Vector3(10, 0, 0), angular=geometry_msgs.Vector3(0, 0, 0))
        self.model_interface_set_twist(SetModelTwistRequest(self.param.car_name, twist))

        # Wait for some time...
        rospy.sleep(self.param.sleep_time)

        received_twist = self.model_interface_get_twist(GetModelTwistRequest(self.param.car_name)).twist
        rospy.loginfo(f"Received twist: {received_twist}")
        self.assertAlmostEqual(Vector(twist.linear), Vector(received_twist.linear), delta=self.param.tolerance)
        self.assertAlmostEqual(Vector(twist.angular), Vector(received_twist.angular), delta=self.param.tolerance)


if __name__ == "__main__":

    rostest.rosrun(PKG, "test_model_interface_node", ModelInterfaceNodeTest, sys.argv)
