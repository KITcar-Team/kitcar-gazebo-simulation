image: git.kitcar-team.de:4567/kitcar/kitcar-gazebo-simulation/ci:focal

variables:
  GIT_STRATEGY: clone
  GIT_LFS_SKIP_SMUDGE: "1"  #  Don't pull Git LFS
  CAR_NAME: dr_drift
  KITCAR_REPO_PATH: /builds/kitcar/

before_script:
  # Run the container start script to enable the pulseaudio & xserver
  - bash init/docker_start_script.sh

  # Print out python version for debugging
  - python3 -V

  # Install packages and requirements
  # Leave out machine learning packages because they are not used within the CI right now.
  - printf '1\nyn' | ./init/init.sh || true

  - source init/bashrc || true

stages:
  - build
  - test
  - deploy


######## BUILD STAGE ########
# buikd kitcar-ros and simulation
build-code:
  stage: build
  script: &build-all
    - cd  simulation
    - catkin_make
  artifacts:
    paths:
      - simulation/devel
      - simulation/build
    expire_in: 2 day

######## TEST STAGE #########

# Run module test in utils packages
test-python-packages:
  stage: test
  script: &test-utils
    - python3 -m simulation.utils.geometry.test
    - python3 simulation/utils/ros_base/test/parameter_object_test.py

    - python3 -m simulation.utils.road.sections.test

    - python3 -m simulation.src.simulation_evaluation.src.speaker.speakers.test
    - python3 -m simulation.src.simulation_evaluation.src.state_machine.test

    # Test the urdf package
    - python3 simulation/utils/urdf/test/test_core.py

test-ros-packages:
  stage: test
  script:
    - cd simulation
    - catkin_make run_tests -j1
    - catkin_test_results  # Ensure that pipeline fails when test fails

# Run tests to ensure that the evaluation pipeline is working
test-drive-evaluation:
  stage: test
  tags:
    # Always require to use the workstation to ensure enough computational power
    - workstation
  variables:
    DISPLAY: ":1.0"
    PATH_FILES: "$KITCAR_REPO_PATH/kitcar-gazebo-simulation/simulation/src/simulation_evaluation/param/drive/paths"
  script:
    # The drive.test is used to evaluate how the car drives.
    # With automatic_drive:=true the path of the car is predetermined and thus the correctness
    # of the evaluation can be tested.

    # #### Road: ci_roads/curves.py ####
    # Simple left and right curve
    # Success: Drive on right lane
    - rostest simulation_evaluation drive.test time_limit:=300 road:=ci_roads/curves automatic_drive:=true
    # Failure: driving onto the left lane
    - rostest simulation_evaluation drive.test time_limit:=300 road:=ci_roads/curves automatic_drive:=true path_file:=$PATH_FILES/left_lane.yaml expected_result_state:=3
    # Failure: by driving off road
    - rostest simulation_evaluation drive.test time_limit:=300 road:=ci_roads/curves automatic_drive:=true path_file:=$PATH_FILES/off_road.yaml expected_result_state:=3

    # #### Road: ci_roads/obstacles.py ####
    # Road with multiple obstacles
    # Failure: Car will hit the obstacles
    - rostest simulation_evaluation drive.test time_limit:=300 road:=ci_roads/obstacles expected_result_state:=3 automatic_drive:=true
    # Success: Car evades the obstacles
    - rostest simulation_evaluation drive.test time_limit:=300 road:=ci_roads/obstacles automatic_drive:=true path_file:=$PATH_FILES/obstacles.yaml

    # #### Road: ci_roads/intersection.py ####
    # Road with an intersection
    - export INTERSECTION_TURN=0 # Don't turn
    - export INTERSECTION_RULE=0 # Equal priority
    - rostest simulation_evaluation drive.test time_limit:=300 road:=ci_roads/intersection automatic_drive:=true
    # Turn left
    - export INTERSECTION_TURN=1
    - export INTERSECTION_RULE=0 # Equal priority
    - rostest simulation_evaluation drive.test time_limit:=300 road:=ci_roads/intersection automatic_drive:=true
    # Turn right
    - export INTERSECTION_TURN=2
    - export INTERSECTION_RULE=0 # Equal priority
    - rostest simulation_evaluation drive.test time_limit:=300 road:=ci_roads/intersection automatic_drive:=true
    # Supposed to yield (failure)
    - export INTERSECTION_TURN=0
    - export INTERSECTION_RULE=1
    - rostest simulation_evaluation drive.test time_limit:=300 road:=ci_roads/intersection automatic_drive:=true expected_result_state:=3
    # Supposed to stop (failure)
    - export INTERSECTION_TURN=0
    - export INTERSECTION_RULE=2
    - rostest simulation_evaluation drive.test time_limit:=300 road:=ci_roads/intersection automatic_drive:=true expected_result_state:=3

    # #### Road: ci_roads/blocked_area.py ####
    # Drive around the blocked area
    - rostest simulation_evaluation drive.test time_limit:=300 road:=ci_roads/blocked_area automatic_drive:=true path_file:=$PATH_FILES/blocked_area.yaml
    # Drive into the blocked area
    - rostest simulation_evaluation drive.test time_limit:=300 road:=ci_roads/blocked_area automatic_drive:=true expected_result_state:=3



test-documentation:
  stage: test
  variables:
    GIT_LFS_SKIP_SMUDGE: "0"  #  Pull git lfs
  script:
    # Test if the onboarding documentation is correct
    - python3 docs/content/tutorials/road_examples/example.py
    - cd docs
    - make doctest

######### Documentation ########

# Build the sphinx documentation
# If this is the master branch, the website deployer will also update doc.kitcar-team.de!
build-documentation:
  stage: deploy
  variables:
    GIT_LFS_SKIP_SMUDGE: "0"  #  Pull git lfs
  script:
    # Build the documentation
    - cd docs
    - make html
  artifacts: # Extract artifacts to view the documentation that has been generated
    paths:
      - docs/_build/html/*
    expire_in: 2 day

# Build and deploy the CI docker image to the gitlab registry
# This is done everytime the master branch is updated
deploy-docker-images:
  stage: deploy
  image: docker:19.03.11
  # Always run on master
  # Allow to manually build the ci image
  # E.g. to test if the Dockerfile is still working
  rules:
  - if: '$CI_COMMIT_REF_NAME == "master"'
  - when: manual
  tags:
    - docker
  services:
    - docker:19.03.11-dind
  variables:
    # Ensure that lfs files are available in resulting images!
    GIT_LFS_SKIP_SMUDGE: "0"  #  Pull Git LFS
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
  before_script:
   - |
      if [ "$CI_COMMIT_REF_NAME" == "master" ]; then
        export TAG_CI_IMAGE=focal
        export TAG_DEFAULT_IMAGE=focal
        export TAG_DEFAULT_IMAGE_CI=ci
        export TAG_KITCAR_ROS_IMAGE=focal
      else
        export TAG_CI_IMAGE=focal_${CI_COMMIT_REF_NAME}
        export TAG_DEFAULT_IMAGE=focal_${CI_COMMIT_REF_NAME}
        export TAG_DEFAULT_IMAGE_CI=ci_${CI_COMMIT_REF_NAME}
        export TAG_KITCAR_ROS_IMAGE=focal_${CI_COMMIT_REF_NAME}
      fi
  script:
    - docker --version
    - docker info
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    # Test building the ci image
    - cd simulation/docker/ci
    - /bin/sh build.sh $CI_REGISTRY $TAG_CI_IMAGE
    - docker push $CI_REGISTRY/kitcar/kitcar-gazebo-simulation/ci:$TAG_CI_IMAGE
    # Test building the default image
    - cd ../default
    - /bin/sh build.sh $CI_REGISTRY $TAG_CI_IMAGE $TAG_DEFAULT_IMAGE_CI $KITCAR_REPO_PATH
    - docker push $CI_REGISTRY/kitcar/kitcar-gazebo-simulation:$TAG_DEFAULT_IMAGE_CI
    - /bin/sh build.sh $CI_REGISTRY $TAG_CI_IMAGE $TAG_DEFAULT_IMAGE /home/kitcar/
    - docker push $CI_REGISTRY/kitcar/kitcar-gazebo-simulation:$TAG_DEFAULT_IMAGE
    # Test building the kitcar_ros_ci image
    - cd ../kitcar_ros_ci
    - /bin/sh build.sh $CI_REGISTRY $TAG_DEFAULT_IMAGE_CI $TAG_KITCAR_ROS_IMAGE
    - docker push $CI_REGISTRY/kitcar/kitcar-gazebo-simulation/kitcar_ros_ci:$TAG_KITCAR_ROS_IMAGE
